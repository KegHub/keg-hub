{"version":3,"file":"joinRegex-1a62e8df.js","sources":["../../src/regex/getRegexSource.js","../../src/regex/joinRegex.js"],"sourcesContent":["/** @module RegEx */\n\nimport { isRegex } from './isRegex'\nimport { isStr } from '../string'\n\n/**\n * Attempts to return a regex string from maybeRx.\n * @function\n * @param {*} maybeRx - any time\n * @return {string?} If maybeRx is a RegExp instance, returns its .source\n * property. If it is a string, returns it unchanged.\n * Otherwise, returns null.\n *\n * @example\n * getRegexSource(/[A-z]+/) // '[A-z]+'\n * getRegexSource('test') // 'test'\n * getRegexSource(34) // null\n */\nexport const getRegexSource = maybeRx =>\n  isRegex(maybeRx) ? maybeRx.source : isStr(maybeRx) ? maybeRx : null\n","/** @module RegEx */\n\nimport { isStr } from '../string'\nimport { isArr } from '../array'\nimport { getRegexSource } from './getRegexSource'\n\n/**\n * Helper for `joinRegex` that parses the args\n * @param {...*} args\n * @return {Array} [\n *  expressions array,\n *  options string\n * ]\n */\nconst parseArgs = args => {\n  if (isArr(args[0])) return [ args[0], args[1] ]\n  const last = args[args.length - 1]\n  const options = isStr(last) ? last : undefined\n  const expressions = options ? args.splice(0, args.length - 1) : args\n  return [ expressions, options ]\n}\n\n/**\n * Joins regex together in one expression\n * <br/>You can technically use strings as well\n * <br/>But be careful that it's not the last element of a spread call\n * <br/>Or that will be interpreted as the \"options\" string.\n * @function\n * @param {...RegExp} expressions array of regex instances.\n * @example\n * // calling using spread args\n * const joined = joinRegex(/[A-z]+/, /[0-9]/, 'g')\n * joined === /([A-z]+|[0-9])/g\n * @example\n * // calling with an array\n * const joined = joinRegex([ ...allMyRegEx ], 'gi')\n */\nexport const joinRegex = (...args) => {\n  const [ expressions, options ] = parseArgs(args)\n\n  // join the regex together in a capture group with the | operator\n  const source = expressions.reduce((joined, next) => {\n    const nextSource = getRegexSource(next)\n    return !nextSource\n      ? joined\n      : joined === ''\n        ? nextSource\n        : `${joined}|${nextSource}`\n  }, '')\n\n  return new RegExp(`(${source})`, options)\n}\n"],"names":["getRegexSource","maybeRx","isRegex","source","isStr","parseArgs","args","isArr","last","length","options","undefined","expressions","splice","joinRegex","reduce","joined","next","nextSource","RegExp"],"mappings":";;;;;;AAkBO,MAAMA,cAAc,GAAGC,OAAO,IACnCC,OAAO,CAACD,OAAD,CAAP,GAAmBA,OAAO,CAACE,MAA3B,GAAoCC,KAAK,CAACH,OAAD,CAAL,GAAiBA,OAAjB,GAA2B;;ACLjE,MAAMI,SAAS,GAAGC,IAAI,IAAI;AACxB,EAAA,IAAIC,KAAK,CAACD,IAAI,CAAC,CAAD,CAAL,CAAT,EAAoB,OAAO,CAAEA,IAAI,CAAC,CAAD,CAAN,EAAWA,IAAI,CAAC,CAAD,CAAf,CAAP,CAAA;EACpB,MAAME,IAAI,GAAGF,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAAjB,CAAA;EACA,MAAMC,OAAO,GAAGN,KAAK,CAACI,IAAD,CAAL,GAAcA,IAAd,GAAqBG,SAArC,CAAA;AACA,EAAA,MAAMC,WAAW,GAAGF,OAAO,GAAGJ,IAAI,CAACO,MAAL,CAAY,CAAZ,EAAeP,IAAI,CAACG,MAAL,GAAc,CAA7B,CAAH,GAAqCH,IAAhE,CAAA;AACA,EAAA,OAAO,CAAEM,WAAF,EAAeF,OAAf,CAAP,CAAA;AACD,CAND,CAAA;MAuBaI,SAAS,GAAG,CAAC,GAAGR,IAAJ,KAAa;EACpC,MAAM,CAAEM,WAAF,EAAeF,OAAf,CAAA,GAA2BL,SAAS,CAACC,IAAD,CAA1C,CADoC;EAIpC,MAAMH,MAAM,GAAGS,WAAW,CAACG,MAAZ,CAAmB,CAACC,MAAD,EAASC,IAAT,KAAkB;AAClD,IAAA,MAAMC,UAAU,GAAGlB,cAAc,CAACiB,IAAD,CAAjC,CAAA;AACA,IAAA,OAAO,CAACC,UAAD,GACHF,MADG,GAEHA,MAAM,KAAK,EAAX,GACEE,UADF,GAEG,CAAA,EAAEF,MAAO,CAAA,CAAA,EAAGE,UAAW,CAJ9B,CAAA,CAAA;GAFa,EAOZ,EAPY,CAAf,CAAA;EASA,OAAO,IAAIC,MAAJ,CAAY,CAAA,CAAA,EAAGhB,MAAO,CAAtB,CAAA,CAAA,EAA0BO,OAA1B,CAAP,CAAA;AACD;;;;"}