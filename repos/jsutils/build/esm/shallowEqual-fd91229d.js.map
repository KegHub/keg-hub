{"version":3,"file":"shallowEqual-fd91229d.js","sources":["../../src/collection/cleanColl.js","../../src/collection/mapColl.js","../../src/collection/mapFind.js","../../src/collection/reduceColl.js","../../src/collection/unset.js","../../src/collection/repeat.js","../../src/collection/shallowEqual.js"],"sourcesContent":["/** @module Collection */\n\nimport { isObj } from '../object/isObj'\nimport { isColl } from './isColl'\n\n/**\n * Cleans a collection by creating a new collection\n * With the null and undefined values removed\n * @function\n * @param {Object|Array} coll - Collection to remove empty values from\n * @param {Boolean} [recursive=true] - Should recursively clean child values\n *\n * @returns {Object|Array} - Cleaned collection\n */\nexport const cleanColl = (coll, recursive = true) => {\n  return isColl(coll)\n    ? Object.keys(coll).reduce((cleaned, key) => {\n      const value = coll[key]\n      if (value === null || value === undefined) return cleaned\n\n      cleaned[key] = recursive && isColl(value) ? cleanColl(value) : value\n\n      return cleaned\n    }, (isObj(coll) && {}) || [])\n    : console.error(`cleanColl requires a collection as the first argument`) ||\n        coll\n}\n","/** @module Collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Loops over a collection and calls a passed in function for each one.\n * @example\n * mapColl([1, 2, 3], (key, val, coll) => { console.log(key) })\n * // Will log all keys of the collection\n * @function\n * @param {Array|Object} coll - Collection to loop over\n * @return {Array|Object} returns the same type of collection passed in\n */\nexport const mapColl = (coll, cb) =>\n  isFunc(cb) && isColl(coll)\n    ? Object.keys(coll).map(key => cb(key, coll[key], coll))\n    : isArr(coll)\n      ? []\n      : {}\n","/** @module Collection */\n\nimport { isColl } from './isColl'\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\nimport { exists } from '../ext/exists'\nimport { validate } from '../validation'\n\n/**\n * Helper for mapFind, handling the array case\n * @private\n * @param {Array} arr\n * @param {Function} mapper\n * @param {Function} testFunc\n * @returns {*}\n */\nconst mapFindArr = (arr, mapper, testFunc) => {\n  // iterate over each value in the array,\n  // returning when a mapped value is found that passes `testFunc`\n  for (let i = 0; i < arr.length; i++) {\n    const mappedValue = mapper(arr[i], i, i)\n    if (testFunc(mappedValue, i, i)) return mappedValue\n  }\n\n  return null\n}\n\n/**\n * Helper for mapFind, handling the object case\n * @private\n * @param {Object} obj\n * @param {Function} mapper\n * @param {Function} testFunc\n * @returns {*}\n */\nconst mapFindObj = (obj, mapper, testFunc) => {\n  let idx = 0\n\n  // iterate over each property in the object\n  // returning when a mapped value is found that passes `testFunc`\n  for (let key in obj) {\n    if (!obj.hasOwnProperty(key)) continue\n\n    const value = obj[key]\n    const mappedValue = mapper(value, key, idx)\n    if (testFunc(mappedValue, key, idx)) return mappedValue\n\n    idx++\n  }\n\n  return null\n}\n\n/**\n * Finds the first element in coll whose mapped value passes the testFunc function, then returns\n * the **mapped** value.\n * It will not map the entire array or object; only the subset needed to find the first passing element.\n * @function\n * @param {Array|Object} coll - Elements to map and find\n * @param {Function} mapper - Mapping function of form: (value, key, idx) -> *. \"key\" is the index when coll is an array. \"idx\" is the index of the array value or object entry.\n * @param {Function?} testFunc - Predicate function of form: (mappedValue, key, idx) -> true/false. Defaults to checking if the mapped value is defined. \"key\" is the index when coll is an array.\n * @returns {*} - The first passing mapped value\n *\n * @example\n * // Find the first file path that can be required from disk\n * const filePaths = [...]\n * const loadedFile = mapFind(filePaths, tryRequireSync)\n *\n * @example\n * // Find the first file path whose required value is an object\n * const filePaths = [...]\n * const loadedFile = mapFind(filePaths, tryRequireSync, isObj)\n *\n * @example\n * // Find the first file path whose required value is an object\n * const filePaths = { document: \"foo/bar/doc.txt\", image: \"foo/bar/pic.img\"}\n * const loadedFile = mapFind(filePaths, (value, key) => tryRequireSync(value), isObj)\n */\nexport const mapFind = (coll, mapper, testFunc = exists) => {\n  const [valid] = validate(\n    { coll, mapper, testFunc },\n    { coll: isColl, $default: isFunc }\n  )\n  if (!valid) return undefined\n\n  return isObj(coll)\n    ? mapFindObj(coll, mapper, testFunc)\n    : mapFindArr(coll, mapper, testFunc)\n}\n","/** @module Collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Loops over collection and calls reduce.\n * @example\n * reduceColl([1, 2, 3], (key, val, coll) => { console.log(key) }, {})\n * // Returns what ever is returned from the last iteration of the reduce loop\n * @function\n * @param {Object|Array} obj - Object to loop over its keys\n * @param {Function} cb - Predicate function to call for each key of the collection\n * @param {*} [reduce] - Starting data passed to reduce method\n * @return {Object} - Last returned data from the loop\n */\nexport const reduceColl = (coll, cb, reduce) =>\n  isFunc(cb) && isColl(coll)\n    ? Object.keys(coll).reduce(\n      (data, key) => cb(key, coll[key], coll, data),\n      reduce\n    )\n    : isArr(coll)\n      ? []\n      : {}\n","/** @module Collection */\n\nimport { updateColl } from './updateColl'\n\n/**\n * Removes a path from an object.\n * @example\n * unset(obj, 'foo.bar')\n * // Returns the passed in obj, with the value of bar set to undefined\n * @function\n * @param {Object} obj - Object to have the attribute removed\n * @param {String|Array} path - Path of attribute to be removed, separated by string\n *\n * @return {Object} - The passed in object, with the attribute found at the path removed\n */\nexport const unset = (obj, path) => {\n  updateColl(obj, path, 'unset')\n\n  return obj\n}\n\n","/** @module Collection */\n\nimport { deepClone } from './deepClone'\nimport { isFunc } from '../method/isFunc'\nimport { isNum } from '../number/isNum'\n\n/**\n * Returns an array composed of element repeated \"times\" times. If element is a function, it will be called.\n * <br/>Note: if you simply want to run a function some number of times, without returning an array of its results, @see Method.doIt\n * @param {*} element - A value or a function. If it is a function, repeat will call it each repeated time\n * @param {Number} times - Number of times that element should be included/called for the resulting array. Anything less than or equal to 0, or not a number, will return an empty array.\n * @function\n * @param {Boolean} cloneDeep - If true, it will deeply clone the element for every instance in the resulting array\n * @returns {Array} - An array of repeated elements or results from the function call\n * @example repeat(1, 3) // returns [1, 1, 1]\n * @example repeat(() => 2 * 2, 3) // returns [4, 4, 4]\n */\nexport const repeat = (element, times, cloneDeep = false) => {\n  if (!times || times <= 0) return []\n  if (!isNum(times)) {\n    console.error('Times argument must be a number')\n    return []\n  }\n  const arr = []\n  for (let i = 0; i < times; i++) {\n    const value = isFunc(element)\n      ? element()\n      : cloneDeep\n        ? deepClone(element)\n        : element\n    arr.push(value)\n  }\n  return arr\n}\n","/** @module Collection */\n\nimport { get } from './get'\nimport { isArr } from '../array/isArr'\nimport { isStr } from '../string/isStr'\nimport { isColl } from './isColl'\n\n/**\n * Compares a collection's keys / values with another collections keys / values\n * @example\n * shallowEqual({ foo: 'bar' }, { foo: 'bar' })\n * // Returns true\n * @example\n * shallowEqual({ foo: 'bar', baz: {} }, { foo: 'bar', baz: {} })\n * // Returns false, because the baz values are different objects\n * @example\n * // Works with array too\n * shallowEqual([ 1, 2 ], [ 1, 2 ])\n * // Returns true\n * @example\n * shallowEqual([{ foo: 'bar' }], [{ foo: 'bar' }])\n * // Returns false, because the objects in index 0 are different\n * @example\n * // Pass a path to compare instead of the root\n * shallowEqual({ foo: { bar: { baz: 'biz' }}}, { foo: { bar: { baz: 'biz' }}}, 'foo.bar')\n * // Returns true, because the bar object is compared\n * @function\n * @param {Object|Array} col1 - Collection to compare\n * @param {Object|Array} col2 - Collection to compare\n * @param {Array|string} path - Path of object to compare. Uses the get method to find the path\n *\n * @returns {Boolean} - true or false if the objects keys values are equal\n */\nexport const shallowEqual = (col1, col2, path) => {\n  // If a path is passed in, update the collections to be that path\n  if (path && (isArr(path) || isStr(path))) {\n    col1 = get(col1, path)\n    col2 = get(col2, path)\n  }\n\n  // If the objects are the same, so return true\n  if (col1 === col2) return true\n\n  // Ensure the objects exist, and they have keys we can compare\n  if (!col1 || !isColl(col1) || !col2 || !isColl(col2)) return false\n\n  // If they have different key lengths, then they are not equal\n  if (Object.keys(col1).length !== Object.keys(col2).length) return false\n\n  // Loop the keys, and ensure the other collection has the key and it's value is the same\n  for (const key in col1) if (col1[key] !== col2[key]) return false\n\n  // Keys and values are equal, so return true\n  return true\n}\n"],"names":["cleanColl","coll","recursive","isColl","Object","keys","reduce","cleaned","key","value","undefined","isObj","console","error","mapColl","cb","isFunc","map","isArr","mapFindArr","arr","mapper","testFunc","i","length","mappedValue","mapFindObj","obj","idx","hasOwnProperty","mapFind","exists","valid","validate","$default","reduceColl","data","unset","path","updateColl","repeat","element","times","cloneDeep","isNum","deepClone","push","shallowEqual","col1","col2","isStr","get"],"mappings":"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"}