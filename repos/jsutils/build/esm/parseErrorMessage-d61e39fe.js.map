{"version":3,"file":"parseErrorMessage-d61e39fe.js","sources":["../../src/method/checkCall.js","../../src/method/complement.js","../../src/method/eitherFunc.js","../../src/method/debounce.js","../../src/method/doIt.js","../../src/method/hasDomAccess.js","../../src/method/memorize.js","../../src/method/runSeq.js","../../src/method/timedRun.js","../../src/method/throttle.js","../../src/method/throttleLast.js","../../src/method/limbo.js","../../src/method/uuid.js","../../src/method/noOp.js","../../src/method/parseErrorMessage.js"],"sourcesContent":["import { isFunc } from './isFunc'\n\n/**\n * Check if the passed in method is a function, and calls it\n * @example\n * checkCall((param1) => { return param1 }, 'foo')\n * // Returns 'foo'\n * @function\n * @param {Function} method - function to call\n * @param {Object} params - params to pass to the method on call\n * @return {*} - whatever the passed in method returns\n */\nexport const checkCall = (method, ...params) => {\n  return isFunc(method) ? method(...params) : undefined\n}\n","import { validate } from '../validation'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Returns a new function that is the complement of predicate function `predicate`\n * @function\n * @param {Function} predicate\n * @returns {Function?} the complement of `predicate`, if it's a function, otherwise null\n * @example\n * const isNegative = x => (x < 0)\n * const isNonNegative = complement(isNegative)\n * isNonNegative(1) // true\n */\nexport const complement = predicate => {\n  const [valid] = validate({ predicate }, { predicate: isFunc })\n  return valid ? (...args) => !predicate(...args) : null\n}\n","import { isFunc } from './isFunc'\n\n/**\n * Returns the first param if it's a function.\n * <br/>If first param is not a function, returns second param.\n * @example\n * eitherFunc(() => {}, 'bar')\n * // Returns first param because it's a function.\n * @example\n * eitherFunc('foo', 'bar')\n * // Returns 'bar'\n * @function\n * @param {Function} func1 - return if is func\n * @param {Function} func2 - use if first is not an object\n * @returns {Function}\n */\nexport const eitherFunc = (func1, func2) => (isFunc(func1) && func1) || func2\n","import { isFunc } from './isFunc'\n\n/**\n * Limits the amount of calls to a function over time\n * @example\n * debounce(myFunction)\n * // Calls myFunction after the default 250 ms\n * @example\n * debounce(myFunction, 500)\n * // Calls myFunction after 500 ms\n * @example\n * debounce(myFunction, 500, true)\n * // Calls myFunction immediately\n * @function\n * @param {Function} func - function to call\n * @param {Number} wait - how long to wait between function calls\n * @param {Boolean} immediate - should call immediately\n * @return { void }\n */\nexport const debounce = (func, wait = 250, immediate = false) => {\n  let timeout\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null\n\n    const context = this\n    const later = () => {\n      timeout = null\n      !immediate && func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) return isFunc(func) && func.apply(context, args)\n  }\n  return wrapFunc\n}\n","import { isNum } from '../number/isNum'\nimport { isFunc } from './isFunc'\n\n/**\n * Execute a method n times.\n * <br/>Callback params - does not include number || callback method\n * @function\n * @example\n * doIt(10, window, [], (index, arr) => { arr.push(index) }) === [ 0,1,2 ... 8,9 ]\n * @param {Number} args.0 - number of times to call the callback\n * @param {parent} args.1 - value to bind the method call to ( this )\n * @param {Function} last arg of args array - method to call\n * @return { void }\n */\nexport const doIt = (...args) => {\n  const params = args.slice()\n  const num = params.shift()\n  const bindTo = params.shift()\n  const cb = params.pop()\n  if (!isNum(num) || !isFunc(cb)) return []\n\n  const doItAmount = new Array(num)\n  const responses = []\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params)\n    if (data === false) break\n    responses.push(data)\n  }\n\n  return responses\n}\n","/**\n * Checks if there is access to the dom\n * @function\n * @example\n * // In Browser\n * hasDomAccess() === true\n * // In Node\n * hasDomAccess() === false\n * @return {Boolean} True if executed in a browser\n */\nexport const hasDomAccess = () => {\n  try {\n    return !!(\n      typeof window !== 'undefined' &&\n      window.document &&\n      window.document.createElement\n    )\n  }\n  catch (error) {\n    return false\n  }\n}\n","import { isNum } from '../number/isNum'\nimport { hasOwn } from '../object/hasOwn'\nimport { isFunc } from './isFunc'\n\n/**\n * Creates a method to memorize passed in methods output\n * @example\n * memorize(myFunction, cacheKeyFunction)\n * @example\n * memorize(myFunction, cacheKeyFunction, 100)\n * @function\n * @param {Function} func - method to memorize output of\n * @param {Function} getCacheKey - gets the key to save cached output\n *\n * @return {Function} memorized function with cache\n */\nexport const memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || (getCacheKey && !isFunc(getCacheKey)))\n    return console.error('Error: Expected a function', func, getCacheKey)\n\n  let memorized = function () {\n    const cache = memorized.cache\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0]\n\n    if (hasOwn(cache, key)) return cache[key]\n\n    const result = func.apply(this, arguments)\n\n    isNum(limit) && Object.keys(cache).length < limit\n      ? (cache[key] = result)\n      : (memorized.cache = { [key]: result })\n\n    return result\n  }\n\n  memorized.cache = {}\n  memorized.destroy = () => {\n    getCacheKey = undefined\n    memorized.cache = undefined\n    memorized.destroy = undefined\n    memorized = undefined\n  }\n\n  return memorized\n}\n","import { validate } from '../validation/validate'\nimport { isArr } from '../array/isArr'\nimport { isFunc } from './isFunc'\nimport { deepClone } from '../collection/deepClone'\n\n/**\n * Calls each promise-returning function in array `asyncFns`,\n * but awaits each before calling the next. Will pass the\n * index and resolved values of complete functions to each subsequent\n * function, in case any need them.\n * @function\n * @param {Array<Function>} asyncFns - array of functions to call in sequence.\n * Each will be passed (currentIndex, resultsSoFar)\n * @param {boolean?} [options.cloneResults=false] - if true, each function will be\n * passed a deep clone of the results array, rather than the reference to it.\n * @param {boolean?} [options.returnOriginal=true] - if true, any member of asyncFns that\n * is not a function will have its corresponding value in the return array be itself.\n * If this is false, that value will be undefined.\n * @return {Promise<Array<*>>} - returns a promise that resolves to an array of all the\n * asyncFns' return values\n * @example\n * const results = await runSeq(asyncFunctions)\n * @example\n * const results = await runSeq(asyncFunctions, { cloneResults: true, returnOriginal: false })\n */\nexport const runSeq = async (asyncFns = [], options = {}) => {\n  const [valid] = validate({ asyncFns }, { asyncFns: isArr })\n  if (!valid) return []\n\n  const { cloneResults = false, returnOriginal = true } = options\n\n  const results = []\n\n  for (const fn of asyncFns) {\n    const result = isFunc(fn)\n      ? await fn(results.length, cloneResults ? deepClone(results) : results)\n      : returnOriginal\n        ? fn\n        : undefined\n    results.push(result)\n  }\n\n  return results\n}\n","import { validate } from '../validation/validate'\nimport { isFunc } from './isFunc'\n\n/**\n * Executes and times the function `fn`.\n * @function\n * @param {Function} fn\n * @param {...*?} args - any number of arguments to pass to fn when it is called\n * @return {Promise<Array<*, number>>} [ fn output, execution time in ms ]\n * @example\n * const [ result, executionTime ] = timedRun(() => http.get(url)))\n * @example\n * const [ result, executionTime ] = timedRun(http.get, url)\n */\nexport const timedRun = async (fn, ...args) => {\n  const [valid] = validate({ fn }, { fn: isFunc })\n  if (!valid) return [ undefined, -1 ]\n\n  const startTime = new Date()\n  const result = await fn(...args)\n  return [ result, new Date() - startTime ]\n}\n","/**\n * Throttle function calls to only execute once over a wait period\n * @example\n * throttle(() => console.log('throttled'), 50)()\n * @function\n * @param {*} func - method to call after wait\n * @param {Number} [wait=100] time to wait between calls\n * @return {Function} throttled function\n */\nexport const throttle = (func, wait = 100) => {\n  let waiting = false\n  return function (...args) {\n    if (waiting) return\n    waiting = true\n    func.apply(this, args)\n    return setTimeout(() => {\n      waiting = false\n    }, wait)\n  }\n}\n","/**\n * Ensures the last call to the throttled function get called.\n * <br/>Will wait the allotted time, before calling the last call to it.\n * <br/>The final call will not execute until no more calls are made,\n * <br/>Accepts a callback to call each time the throttle called,\n * @example\n * throttleLast(() => {}, () => {})()\n * // throttle function\n * @function\n * @param {Function} func - method to call after wait\n * @param {Function} cb - method to call after throttle function is called\n * @param {Number} [wait=100] time to wait until executing func param\n * @return {Function} throttled function\n */\nexport const throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout\n  return function (...args) {\n    // If the throttle already exists clear it, and create it again\n    if (throttleTimeout) clearTimeout(throttleTimeout)\n    // Store a reference to the timeout\n    // Will wait the allotted time until calling the final call to it\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args)\n      clearTimeout(throttleTimeout)\n    }, wait)\n    typeof cb === 'function' && cb()\n  }\n}\n","import { isFunc } from './isFunc'\n\n/**\n * Response returned from a limbo promise\n * @typedef TLimboResponse\n * @type {Array}\n */\n\n/**\n * Adds catch to a promise for better error handling of await functions\n * <br/>Removes the need for wrapping await in a try / catch\n * <br/>First argument is an Error when the promise throws or null when it resolves\n * <br/>Second argument is the response from the resolved promise\n * @example\n * const [ err, data ] = await limbo(promiseFunction())\n * // returns an array\n * // * err will be undefined if no error was thrown\n * // * data will be the response from the promiseFunction\n * @function\n * @param {Promise<Function>} promise - Promise to be resolved\n * @return {Promise<TLimboResponse>} - Slot 1 => error, Slot 2 => response from promise\n */\nexport const limbo = promise => {\n  return !promise || !isFunc(promise.then)\n    ? [\n        new Error(`A promise or thenable is required as the first argument!`),\n        null,\n      ]\n    : promise.then(data => [ null, data ]).catch(err => [ err, undefined ])\n}\n","/**\n * Creates a uuid, unique up to around 20 million iterations.\n * @example\n * uuid()\n * // New uuid as a string\n * @function\n * @param {Number} [start] of the uuid\n * @return {String} - build uuid\n */\nexport const uuid = a =>\n  a\n    ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)\n    : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid)\n","/**\n * Reusable empty function that is a no-op\n * @function\n * @returns {void}\n */\nexport const noOp = () => {}\n","import { isStr } from '../string/isStr'\nimport { isObj } from '../object/isObj'\nimport { isEmpty } from '../ext/isEmpty'\n\n/**\n * Extracts the message from the exception, whether string or object\n * @function\n * @param {*} exception - Error to be extracted\n * @return {string?} - The message or null if no message is present\n * @example\n * try {\n *   throwSomeException()\n * }\n * catch (err) {\n *   const message = parseErrorMessage(err) || 'Error'\n * }\n */\nexport const parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception)\n    ? exception\n    : isObj(exception)\n      ? exception.message\n      : null\n}\n"],"names":["checkCall","method","params","isFunc","undefined","complement","predicate","valid","validate","args","eitherFunc","func1","func2","debounce","func","wait","immediate","timeout","wrapFunc","context","later","apply","callNow","clearTimeout","setTimeout","doIt","slice","num","shift","bindTo","cb","pop","isNum","doItAmount","Array","responses","i","length","data","call","push","hasDomAccess","window","document","createElement","error","memorize","getCacheKey","limit","console","memorized","cache","key","arguments","hasOwn","result","Object","keys","destroy","runSeq","asyncFns","options","isArr","cloneResults","returnOriginal","results","fn","deepClone","timedRun","startTime","Date","throttle","waiting","throttleLast","throttleTimeout","limbo","promise","then","Error","catch","err","uuid","a","Math","random","toString","replace","noOp","parseErrorMessage","exception","isStr","isEmpty","isObj","message"],"mappings":"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"}