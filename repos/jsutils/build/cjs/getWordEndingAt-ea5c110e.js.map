{"version":3,"file":"getWordEndingAt-ea5c110e.js","sources":["../../src/string/buildPath.js","../../src/string/mapString.js","../../src/string/isLowerCase.js","../../src/string/isUpperCase.js","../../src/string/delimitString.js","../../src/string/snakeCase.js","../../src/string/capitalize.js","../../src/string/removeDot.js","../../src/string/cleanStr.js","../../src/string/camelCase.js","../../src/string/camelCasePath.js","../../src/string/containsStr.js","../../src/string/eitherStr.js","../../src/string/hyphenator.js","../../src/string/hashString.js","../../src/string/isEmail.js","../../src/string/isPhone.js","../../src/string/isUrl.js","../../src/string/isUuid.js","../../src/string/parseJSON.js","../../src/string/plural.js","../../src/string/singular.js","../../src/string/styleCase.js","../../src/string/trainCase.js","../../src/string/wordCaps.js","../../src/string/spaceJoin.js","../../src/string/template.js","../../src/string/validFilename.js","../../src/string/isQuoted.js","../../src/string/reverseStr.js","../../src/string/getWordStartingAt.js","../../src/string/getWordEndingAt.js"],"sourcesContent":["/** @module String */\n\n/**\n * Builds a string path from passed in args ( i.e. path/to/thing ).\n * @function\n * @return {String} - built path from arguments\n */\nexport const buildPath = (...args) => {\n  const built = args.reduce((path, arg) => {\n    let str = toStr(arg)\n\n    return `${path}${(str && '/' + str) || ''}`\n  }, '')\n\n  return built.replace(/([^:\\/]|^)\\/{2,}/g, '$1/')\n}\n","/** @module String */\n\nimport { isFunc } from '../method/isFunc'\nimport { isStr } from './isStr'\n\n/**\n * Maps a string by applying function `charMapper` to each character.\n * @function\n * @param {String} str - String to be mapped\n * @param {Function} charMapper - Function of form (character) => <some character or string>\n * @returns {String} - String with each character mapped by charMap.<br/>If str is not a string or charMapper not a function, just returns the passed in str argument\n * @example\n *  mapString(\"hello\", c => c === 'h' ? 'x' : c) // returns 'xello'\n */\nexport const mapString = (str, charMapper) => {\n  if (!isStr(str)) return str\n  if (!isFunc(charMapper)) return str\n  let result = ''\n  for (const char of str) {\n    result += charMapper(char)\n  }\n  return result\n}\n","/** @module String */\n\n/**\n * Checks if a string is all lowercase letters\n * @function\n * @param {String} str - String to check if it's lowercase\n * @returns {Boolean} - True if str is lowercase\n */\nexport const isLowerCase = str => str === str.toLowerCase()\n","/** @module String */\n\n/**\n * Checks if a string is all capital letters\n * @function\n * @param {String} str - String to check if it's uppercase\n * @returns {Boolean} - True if str is uppercase\n */\nexport const isUpperCase = str => str === str.toUpperCase()\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { mapString } from './mapString'\nimport { isLowerCase } from './isLowerCase'\nimport { isUpperCase } from './isUpperCase'\n\n/**\n * Converts a string into a delimted script based on the passed in arguments\n * @function\n * @param {String} str - string of any casing\n * @param {String} delimiter - How the string should be split e.g. '_'\n * @param {Array<string>} [delimiters] - An array of delimiter characters on which this function searches and breaks.<br/>Defaults to checking -, _, and space\n * @returns {String} - A new string with the specified delimiter delimiting each word\n *\n * @example\n * delimitString('fooBar', '_') === 'foo_Bar'\n */\nexport const delimitString = (str, delimiter, delimiters = [ '-', '_', ' ' ]) => {\n  if (!isStr(str)) return str\n  const isDelimiter = c => delimiters.some(del => del === c)\n  let prevChar = '_'\n  return mapString(str, char => {\n    if (isDelimiter(char)) {\n      prevChar = delimiter\n      return delimiter\n    }\n\n    if (isUpperCase(char) && isLowerCase(prevChar) && !isDelimiter(prevChar)) {\n      prevChar = char\n      return delimiter + char\n    }\n\n    prevChar = char\n    return char\n  })\n}\n","/** @module String */\n\nimport { delimitString } from './delimitString'\n\n/**\n * Converts a string to snake_case.\n * @function\n * @param {String} str - String to be converted\n * @example\n * snakeCase('fooBar') === 'foo_bar'\n * @returns {String} - The string in snake_case, or the input if it is not a string\n */\nexport const snakeCase = str => {\n  const underscored = delimitString(str, '_')\n  return underscored.toLowerCase()\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts first letter of a string to be capitalized.\n * @function\n * @param {String} string\n * @param {Boolean} [lowercaseTail=true] - if true, will also lowercase the all characters except the first\n * @return {String} - Passed in string, but capitalized\n */\nexport const capitalize = (str, lowercaseTail = true) => {\n  if (!isStr(str) || !str[0]) return str\n  const tail = lowercaseTail ? str.slice(1).toLowerCase() : str.slice(1)\n  return `${str[0].toUpperCase()}${tail}`\n}\n","/** @module String */\n\n/**\n * Removes a `.` from the start and end of a string.\n * @function\n * @param {String} str - string to convert\n * @return {String} - string without the `.`\n */\nexport const removeDot = string => {\n  const noDot = string.indexOf('.') === 0 ? string.slice(1) : string\n  return noDot.indexOf('.') === noDot.length - 1 ? noDot.slice(0, -1) : noDot\n}\n","/** @module String */\n\nimport { removeDot } from './removeDot'\n\n/**\n * Converts `-` and `_` to white space and calls remove removeDot, to remove a period.\n * @function\n * @param {String} string to be converted\n * @return {String} - cleaned string\n */\nexport const cleanStr = str => {\n  return (str && removeDot(str).replace(/[-_]/gm, ' ')) || str\n}\n","/** @module String */\n\nimport { capitalize } from './capitalize'\nimport { cleanStr } from './cleanStr'\n\n/**\n * Converts a string to camel case.\n * @function\n * @param {String} string to be converted\n * @return {String} - string in camel case format\n */\nexport const camelCase = (str, compCase) => {\n  return (\n    (str &&\n      cleanStr(str)\n        .split(/[\\s_-]/gm)\n        .reduce((cased, word, index) => {\n          if (!word) return cased\n          cased +=\n            ((index > 0 || compCase) && capitalize(word)) || word.toLowerCase()\n          return cased\n        }, '')) ||\n    str\n  )\n}\n","/** @module String */\n\nimport { capitalize } from './capitalize'\n\n/**\n * Turns a path string into a camel-cased string, if there is more than one\n * step in the path. If there isn't, just returns path.\n * @function\n * @param {String} path\n * @return {String} camel-cased string\n * @example\n * camelCasePath('settings.agendaMap.Count') -> 'settingsAgendaMapCount'\n * camelCasePath('settings') -> 'settings'\n */\nexport const camelCasePath = path => {\n  const split = path.split('.')\n  const camelCasedSplit = split.map((str, idx) =>\n    idx > 0 ? capitalize(str, false) : str\n  )\n\n  return camelCasedSplit.length > 1 ? camelCasedSplit.join('') : path\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { toStr } from './toStr'\n\n/**\n * Checks if a string contains another string.\n * @function\n * @param {String} string - value to be checked\n * @param {String} substring - value to search for\n * @param {Number} [fromIndex] - Index of the string to search from\n * @return {Boolean} - if the substring exists string\n */\nexport const containsStr = (str, substring, fromIndex) => {\n  str = (!isStr(str) && toStr(str)) || str\n  substring = (!isStr(substring) && toStr(substring)) || substring\n\n  return str.indexOf(substring, fromIndex) !== -1\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Checks if the first param is a string, and returns it.\n * <br/>If it's not a string, the second param is returned\n * @function\n * @param {String} str1 - return if is string\n * @param {String} str2 - use if first is not a string\n * @returns {String}\n */\nexport const eitherStr = (str1, str2) => (isStr(str1) && str1) || str2\n","/** @module String */\n\nconst uppercasePattern = /[A-Z]/g\nconst msPattern = /^ms-/\n\n/**\n * Hyphenator cache, that stores already hyphenated text to be reused\n * @private\n * @Object\n */\nconst hyphenCache = {}\n\n/**\n * Converts a matching style rule to lowercase with hyphen\n * External hyphenator helpers, created outside the method to improve performance\n * @function\n * @private\n * @param {String} str - camelCase style rule rule\n *\n * @returns {String} - Lowercase style rule with hyphen at the start\n */\nconst toHyphenLower = match => '-' + match.toLowerCase()\n\n/**\n * Converts a camelCase style rule into a hyphenated style rule\n * <br/>Caches the response to make future conversions faster\n * @function\n * @param {String} str - camelCase style rule rule\n *\n * @returns {String} - Hyphenated style rule\n */\nexport const hyphenator = rule => {\n  if (hyphenCache.hasOwnProperty(rule)) return hyphenCache[rule]\n\n  const hRule = rule.replace(uppercasePattern, toHyphenLower)\n  return (hyphenCache[rule] = msPattern.test(hRule) ? '-' + hRule : hRule)\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { isNonNegative } from '../number/isNonNegative'\n/**\n * Creates a hash from a passed in string consistently\n * <br/>Not intended to be secure\n * <br/>Value comes from being a pure function\n * <br/>Given the same input, it will always return the same output\n * <br/>There is no expectation to convert back from the hash to the original string\n * @function\n * @param {String} str - String to be hashed\n * @param {number=} maxLength - Max length of the returned hash\n *\n * @returns {String} - Hashed version of the string\n */\nexport const hashString = (str, maxLength) => {\n  if (!isStr(str) || str.length == 0) return 0\n\n  str = str.split('').reverse()\n    .join('')\n\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    // Convert to positive 32bit integer\n    hash = `${Math.abs(hash & hash)}`\n  }\n\n  return isNonNegative(maxLength) ? hash.slice(0, maxLength) : hash\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a email.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a email\n */\nexport const isEmail = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a phone number.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - True if str is a phone number\n */\nexport const isPhone = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/im\n  return Boolean(regex.test(str)) && str.replace(/\\D/g, '').length < 11\n}\n","/** @module String */\n\n/**\n * Check if string is a url.\n * @function\n * @param {String} string to check\n * @return {Boolean} - if it's a url\n */\nexport const isUrl = str => {\n  const regex =\n    /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a uuid.\n * @function\n * @param {String} str - string to check\n * @return {Boolean} - if it's a uuid\n */\nexport const isUuid = str => {\n  if (!str || !isStr(str)) return false\n  const regex =\n    /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n  return Boolean(regex.test(str))\n}\n","/** @module String */\n\n/**\n * Convert JSON string into object, wrapped in a try / catch.\n * @function\n * @param {String} string\n * @return {Object} - JSON object\n */\nexport const parseJSON = (str, logErr = true) => {\n  try {\n    return JSON.parse(str)\n  }\n  catch (e) {\n    logErr && console.error(e.message)\n    return null\n  }\n}\n","/** @module String */\n\n/**\n * Adds an `s` to the end of a string, if one does not exist.\n * @function\n * @param {String} str - string to convert\n * @return {String} string as a plural\n */\nexport const plural = str => {\n  if (!str || !str.length) return str\n  return str[str.length - 1] !== 's' ? str + 's' : str\n}\n","/** @module String */\n\n/**\n * Remove an `s` at the end of a string, if the last char is an `s`,\n * @function\n * @param {String} str - string to convert\n * @return {String} string as singular\n */\nexport const singular = str => {\n  if (!str || !str.length) return str\n  return str[str.length - 1] === 's' ? str.slice(0, str.length - 1) : str\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { camelCase } from './camelCase'\n\n/**\n * Converts a string to css in js format.\n * Useful for converting css rules into js format, I.E. margin-top => marginTop.\n * @function\n * @param {String} str - string to be converted\n * @return {String} - string in style case format\n */\nexport const styleCase = str => {\n  if (!isStr(str)) return str\n\n  const cased = camelCase(str)\n  return `${cased[0].toLowerCase()}${cased.slice(1)}`\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts a string to train case, I.E. marginTop => margin-top.\n * @function\n * @param {String} string to be converted\n * @return {String} - string in train case format\n */\nexport const trainCase = str =>\n  (isStr(str) &&\n    str\n      .split(/(?=[A-Z])|[\\s_-]/gm)\n      .join('-')\n      .toLowerCase()) ||\n  str\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { cleanStr } from './cleanStr'\nimport { capitalize } from './capitalize'\n\n/**\n * Converts all words in a string to be capitalized.\n * @function\n * @param {String} string to be converted\n * @return {String} - string with all words capitalized\n */\nexport const wordCaps = str => {\n  if (!isStr(str)) return str\n  let cleaned = cleanStr(str)\n  return cleaned\n    .split(' ')\n    .map(word => (word && capitalize(word)) || '')\n    .join(' ')\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\nimport { isArr } from '../array/isArr'\n\n/**\n * Joins strings and array of string together with spaces\n * @function\n * @param {String} original - The default string that other strings get added to\n * @param {string|Array} toAdd - String of Array of Strings to add to the original\n *\n * @returns {String} Joined strings seperated by space\n */\nexport const spaceJoin = (original, toAdd) => {\n  toAdd = isArr(toAdd) ? toAdd : [toAdd]\n  return toAdd.reduce(\n    (joined, item) => {\n      return isStr(item)\n        ? `${joined ? joined + ' ' : ''}${item}`.trim()\n        : joined\n    },\n    isStr(original) ? original : ''\n  )\n}\n","/** @module String */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from '../collection/isColl'\nimport { get } from '../collection/get'\nimport { isStr } from './isStr'\n\n/**\n * Helper to wrap the template method, and allow passing a custom regex argument\n * Custom regex is used instead the default regex of the template method\n * @function\n * @example\n * template('${{ who }} in ${{ where }}!', { who: 'goats', where: 'boats' })\n * // Returns \"goats in boats\"\n * @param {String} template - String with ES6 syntax items to be replaced\n * @param {Object|Array} data - Data used to replace the ES6 placeholders\n * @param {any} fallback - Used it data does not contain key to be replaced\n * @param {Object} [RegEx?] - Regular Express to replace the default\n *\n * @returns {String} - template with placeholder values filled\n */\nexport const templateRx = (tempStr, data, fallback = '', rx) => {\n  const orgRx = template.regex\n  template.regex = rx || /{{([^}]*)}}/g\n  const resp = template(tempStr, data, fallback)\n  template.regex = orgRx\n\n  return resp\n}\n\n/**\n * Simple template replace for ES6 template strings\n * @function\n * @example\n * template('${ who } in ${ where }!', { who: 'goats', where: 'boats' })\n * // Returns \"goats in boats\"\n * @param {String} template - String with ES6 syntax items to be replaced\n * @param {Object|Array} data - Data used to replace the ES6 placeholders\n * @param {any} fallback - Used it data does not contain key to be replaced\n *\n * @returns {String} - template with placeholder values filled\n */\nexport const template = (tempStr, data, fallback = '') => {\n  data = (isColl(data) && data) || {}\n  const regex = template.regex || /\\${(.*?)\\}/g\n\n  return isStr(tempStr)\n    ? tempStr.replace(regex, (match, exact) => {\n      const path = (exact || match.substr(2, match.length - 3)).trim()\n      const replaceWith = get(data, path, fallback)\n      return isFunc(replaceWith)\n        ? replaceWith(data, path, fallback)\n        : replaceWith\n    })\n    : console.error(`template requires a string as the first argument`) ||\n        tempStr\n}\n","/** @module String */\n\n/**\n * Checks whether a given string is a valid filename\n * @function\n * @param {String} fileName - The file name to check if valid\n *\n * @returns {Boolean}\n */\nexport const validFilename = fileName => {\n  if (!fileName) return false\n  // On Unix-like systems '/' is reserved\n  // and <>:\"/\\|?* as well as non-printable characters \\u0000-\\u001F on Windows\n  const regex = /[<>:\"/\\\\|?*\\u0000-\\u001F]/g\n\n  // invalid Windows filenames\n  const windowsRegex = /^(con|prn|aux|nul|com\\d|lpt\\d)$/i\n\n  // starts with period\n  const periodRegex = /^\\.\\.?$/\n\n  return regex.test(fileName) ||\n    windowsRegex.test(fileName) ||\n    periodRegex.test(fileName)\n    ? false\n    : true\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\nconst quoteSymbols = [ '\"', \"'\" ]\n\n/**\n * Checks if the string contains quoted text\n * @function\n * @param {String} str - string to check\n * @param {Array<string>?} [quotes] - optional array of valid quote strings to check with. Defaults to single and double quote characters.\n * @return {Boolean} true if `str` is a quoted string\n * @example\n * isQuoted('foo') // false\n * @example\n * isQuoted('\"foo\"') // true\n */\nexport const isQuoted = (str, quotes = quoteSymbols) => {\n  return (\n    isStr(str) &&\n    quotes.some(quote => str.startsWith(quote) && str.endsWith(quote))\n  )\n}\n","/** @module String */\n\nimport { isStr } from './isStr'\n\n/**\n * Reverses string\n * @function\n * @param {String} str - string to reverse\n * @return {String} reversed str\n * @example\n * reverseStr('foo') // 'oof'\n */\nexport const reverseStr = str => {\n  if (!isStr(str)) return undefined\n  let reversed = ''\n  for (let char of str) {\n    reversed = char + reversed\n  }\n  return reversed\n}\n","/** @module String */\n\n/**\n * Helper for `getWordStartingAt` that finds the\n * index of the exclusive end of the word, given the available\n * ending delimiters\n * @function\n * @param {String} text\n * @param {Number} index\n * @param {Array<string>} delimiters\n */\nexport const getNearestDelimiterIndex = (text, index, delimiters = [' ']) => {\n  const indices = delimiters.map(str => text.indexOf(str, index)).sort()\n  return indices.find(idx => idx >= 0)\n}\n\n/**\n * Gets the word in text starting at index\n * @function\n * @param {String} text\n * @param {Number} index - the inclusive starting index of the word to get\n * @param {Array<string>?} delimiters - optional array of strings that delimit words. Defaults to the space character.\n * @example\n * const text = 'foo bar bin'\n * const word = getWordStartingAt(text, 4)\n * word === 'bar'\n */\nexport const getWordStartingAt = (text, index, delimiters = [' ']) => {\n  const endingSpaceIdx = getNearestDelimiterIndex(text, index, delimiters)\n  return text.substring(\n    index,\n    endingSpaceIdx === -1 ? text.length : endingSpaceIdx\n  )\n}\n","/** @module String */\n\nimport { reverseStr } from './reverseStr'\nimport { getWordStartingAt } from './getWordStartingAt'\n\n/**\n * Gets the word in text ending at index (exclusive)\n * @function\n * @param {String} text\n * @param {Number} index - the exclusive ending index of the word to get\n * @param {Array<string>?} delimiters - optional array of strings that delimit the start of words. Defaults to the space character.\n * @example\n * const text = 'foo bar bin'\n * const word = getWordEndingAt(text, 3)\n * word === 'foo'\n */\nexport const getWordEndingAt = (text, index, delimiters = [' ']) => {\n  const reversed = reverseStr(text)\n  const reversedIndex = text.length - index\n  return reverseStr(getWordStartingAt(reversed, reversedIndex, delimiters))\n}\n"],"names":["buildPath","args","built","reduce","path","arg","str","toStr","replace","mapString","charMapper","isStr","isFunc","result","char","isLowerCase","toLowerCase","isUpperCase","toUpperCase","delimitString","delimiter","delimiters","isDelimiter","c","some","del","prevChar","snakeCase","underscored","capitalize","lowercaseTail","tail","slice","removeDot","string","noDot","indexOf","length","cleanStr","camelCase","compCase","split","cased","word","index","camelCasePath","camelCasedSplit","map","idx","join","containsStr","substring","fromIndex","eitherStr","str1","str2","uppercasePattern","msPattern","hyphenCache","toHyphenLower","match","hyphenator","rule","hasOwnProperty","hRule","test","hashString","maxLength","reverse","hash","i","charCodeAt","Math","abs","isNonNegative","isEmail","regex","Boolean","isPhone","isUrl","isUuid","parseJSON","logErr","JSON","parse","e","console","error","message","plural","singular","styleCase","trainCase","wordCaps","cleaned","spaceJoin","original","toAdd","isArr","joined","item","trim","templateRx","tempStr","data","fallback","rx","orgRx","template","resp","isColl","exact","substr","replaceWith","get","validFilename","fileName","windowsRegex","periodRegex","quoteSymbols","isQuoted","quotes","quote","startsWith","endsWith","reverseStr","undefined","reversed","getNearestDelimiterIndex","text","indices","sort","find","getWordStartingAt","endingSpaceIdx","getWordEndingAt","reversedIndex"],"mappings":";;;;;;;;;;MAOaA,SAAS,GAAG,CAAC,GAAGC,IAAJ,KAAa;AACpC,QAAMC,KAAK,GAAGD,IAAI,CAACE,MAAL,CAAY,CAACC,IAAD,EAAOC,GAAP,KAAe;AACvC,QAAIC,GAAG,GAAGC,KAAK,CAACF,GAAD,CAAf;AAEA,WAAQ,GAAED,IAAK,GAAGE,GAAG,IAAI,MAAMA,GAAd,IAAsB,EAAG,EAA1C;AACD,GAJa,EAIX,EAJW,CAAd;AAMA,SAAOJ,KAAK,CAACM,OAAN,CAAc,mBAAd,EAAmC,KAAnC,CAAP;AACD;;MCDYC,SAAS,GAAG,CAACH,GAAD,EAAMI,UAAN,KAAqB;AAC5C,MAAI,CAACC,WAAK,CAACL,GAAD,CAAV,EAAiB,OAAOA,GAAP;AACjB,MAAI,CAACM,aAAM,CAACF,UAAD,CAAX,EAAyB,OAAOJ,GAAP;AACzB,MAAIO,MAAM,GAAG,EAAb;AACA,OAAK,MAAMC,IAAX,IAAmBR,GAAnB,EAAwB;AACtBO,IAAAA,MAAM,IAAIH,UAAU,CAACI,IAAD,CAApB;AACD;AACD,SAAOD,MAAP;AACD;;MCdYE,WAAW,GAAGT,GAAG,IAAIA,GAAG,KAAKA,GAAG,CAACU,WAAJ;;MCA7BC,WAAW,GAAGX,GAAG,IAAIA,GAAG,KAAKA,GAAG,CAACY,WAAJ;;MCU7BC,aAAa,GAAG,CAACb,GAAD,EAAMc,SAAN,EAAiBC,UAAU,GAAG,CAAE,GAAF,EAAO,GAAP,EAAY,GAAZ,CAA9B,KAAoD;AAC/E,MAAI,CAACV,WAAK,CAACL,GAAD,CAAV,EAAiB,OAAOA,GAAP;AACjB,QAAMgB,WAAW,GAAGC,CAAC,IAAIF,UAAU,CAACG,IAAX,CAAgBC,GAAG,IAAIA,GAAG,KAAKF,CAA/B,CAAzB;AACA,MAAIG,QAAQ,GAAG,GAAf;AACA,SAAOjB,SAAS,CAACH,GAAD,EAAMQ,IAAI,IAAI;AAC5B,QAAIQ,WAAW,CAACR,IAAD,CAAf,EAAuB;AACrBY,MAAAA,QAAQ,GAAGN,SAAX;AACA,aAAOA,SAAP;AACD;AAED,QAAIH,WAAW,CAACH,IAAD,CAAX,IAAqBC,WAAW,CAACW,QAAD,CAAhC,IAA8C,CAACJ,WAAW,CAACI,QAAD,CAA9D,EAA0E;AACxEA,MAAAA,QAAQ,GAAGZ,IAAX;AACA,aAAOM,SAAS,GAAGN,IAAnB;AACD;AAEDY,IAAAA,QAAQ,GAAGZ,IAAX;AACA,WAAOA,IAAP;AACD,GAbe,CAAhB;AAcD;;MCxBYa,SAAS,GAAGrB,GAAG,IAAI;AAC9B,QAAMsB,WAAW,GAAGT,aAAa,CAACb,GAAD,EAAM,GAAN,CAAjC;AACA,SAAOsB,WAAW,CAACZ,WAAZ,EAAP;AACD;;MCJYa,UAAU,GAAG,CAACvB,GAAD,EAAMwB,aAAa,GAAG,IAAtB,KAA+B;AACvD,MAAI,CAACnB,WAAK,CAACL,GAAD,CAAN,IAAe,CAACA,GAAG,CAAC,CAAD,CAAvB,EAA4B,OAAOA,GAAP;AAC5B,QAAMyB,IAAI,GAAGD,aAAa,GAAGxB,GAAG,CAAC0B,KAAJ,CAAU,CAAV,EAAahB,WAAb,EAAH,GAAgCV,GAAG,CAAC0B,KAAJ,CAAU,CAAV,CAA1D;AACA,SAAQ,GAAE1B,GAAG,CAAC,CAAD,CAAH,CAAOY,WAAP,EAAqB,GAAEa,IAAK,EAAtC;AACD;;MCPYE,SAAS,GAAGC,MAAM,IAAI;AACjC,QAAMC,KAAK,GAAGD,MAAM,CAACE,OAAP,CAAe,GAAf,MAAwB,CAAxB,GAA4BF,MAAM,CAACF,KAAP,CAAa,CAAb,CAA5B,GAA8CE,MAA5D;AACA,SAAOC,KAAK,CAACC,OAAN,CAAc,GAAd,MAAuBD,KAAK,CAACE,MAAN,GAAe,CAAtC,GAA0CF,KAAK,CAACH,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAA1C,GAA+DG,KAAtE;AACD;;MCDYG,QAAQ,GAAGhC,GAAG,IAAI;AAC7B,SAAQA,GAAG,IAAI2B,SAAS,CAAC3B,GAAD,CAAT,CAAeE,OAAf,CAAuB,QAAvB,EAAiC,GAAjC,CAAR,IAAkDF,GAAzD;AACD;;MCDYiC,SAAS,GAAG,CAACjC,GAAD,EAAMkC,QAAN,KAAmB;AAC1C,SACGlC,GAAG,IACFgC,QAAQ,CAAChC,GAAD,CAAR,CACGmC,KADH,CACS,UADT,EAEGtC,MAFH,CAEU,CAACuC,KAAD,EAAQC,IAAR,EAAcC,KAAd,KAAwB;AAC9B,QAAI,CAACD,IAAL,EAAW,OAAOD,KAAP;AACXA,IAAAA,KAAK,IACF,CAACE,KAAK,GAAG,CAAR,IAAaJ,QAAd,KAA2BX,UAAU,CAACc,IAAD,CAAtC,IAAiDA,IAAI,CAAC3B,WAAL,EADnD;AAEA,WAAO0B,KAAP;AACD,GAPH,EAOK,EAPL,CADF,IASApC,GAVF;AAYD;;MCVYuC,aAAa,GAAGzC,IAAI,IAAI;AACnC,QAAMqC,KAAK,GAAGrC,IAAI,CAACqC,KAAL,CAAW,GAAX,CAAd;AACA,QAAMK,eAAe,GAAGL,KAAK,CAACM,GAAN,CAAU,CAACzC,GAAD,EAAM0C,GAAN,KAChCA,GAAG,GAAG,CAAN,GAAUnB,UAAU,CAACvB,GAAD,EAAM,KAAN,CAApB,GAAmCA,GADb,CAAxB;AAIA,SAAOwC,eAAe,CAACT,MAAhB,GAAyB,CAAzB,GAA6BS,eAAe,CAACG,IAAhB,CAAqB,EAArB,CAA7B,GAAwD7C,IAA/D;AACD;;MCRY8C,WAAW,GAAG,CAAC5C,GAAD,EAAM6C,SAAN,EAAiBC,SAAjB,KAA+B;AACxD9C,EAAAA,GAAG,GAAI,CAACK,WAAK,CAACL,GAAD,CAAN,IAAeC,aAAK,CAACD,GAAD,CAArB,IAA+BA,GAArC;AACA6C,EAAAA,SAAS,GAAI,CAACxC,WAAK,CAACwC,SAAD,CAAN,IAAqB5C,aAAK,CAAC4C,SAAD,CAA3B,IAA2CA,SAAvD;AAEA,SAAO7C,GAAG,CAAC8B,OAAJ,CAAYe,SAAZ,EAAuBC,SAAvB,MAAsC,CAAC,CAA9C;AACD;;MCNYC,SAAS,GAAG,CAACC,IAAD,EAAOC,IAAP,KAAiB5C,WAAK,CAAC2C,IAAD,CAAL,IAAeA,IAAhB,IAAyBC;;ACVlE,MAAMC,gBAAgB,GAAG,QAAzB;AACA,MAAMC,SAAS,GAAG,MAAlB;AAOA,MAAMC,WAAW,GAAG,EAApB;AAWA,MAAMC,aAAa,GAAGC,KAAK,IAAI,MAAMA,KAAK,CAAC5C,WAAN,EAArC;MAUa6C,UAAU,GAAGC,IAAI,IAAI;AAChC,MAAIJ,WAAW,CAACK,cAAZ,CAA2BD,IAA3B,CAAJ,EAAsC,OAAOJ,WAAW,CAACI,IAAD,CAAlB;AAEtC,QAAME,KAAK,GAAGF,IAAI,CAACtD,OAAL,CAAagD,gBAAb,EAA+BG,aAA/B,CAAd;AACA,SAAQD,WAAW,CAACI,IAAD,CAAX,GAAoBL,SAAS,CAACQ,IAAV,CAAeD,KAAf,IAAwB,MAAMA,KAA9B,GAAsCA,KAAlE;AACD;;MCpBYE,UAAU,GAAG,CAAC5D,GAAD,EAAM6D,SAAN,KAAoB;AAC5C,MAAI,CAACxD,WAAK,CAACL,GAAD,CAAN,IAAeA,GAAG,CAAC+B,MAAJ,IAAc,CAAjC,EAAoC,OAAO,CAAP;AAEpC/B,EAAAA,GAAG,GAAGA,GAAG,CAACmC,KAAJ,CAAU,EAAV,EAAc2B,OAAd,GACHnB,IADG,CACE,EADF,CAAN;AAGA,MAAIoB,IAAI,GAAG,CAAX;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhE,GAAG,CAAC+B,MAAxB,EAAgCiC,CAAC,EAAjC,EAAqC;AACnC,UAAMxD,IAAI,GAAGR,GAAG,CAACiE,UAAJ,CAAeD,CAAf,CAAb;AACAD,IAAAA,IAAI,GAAG,CAACA,IAAI,IAAI,CAAT,IAAcA,IAAd,GAAqBvD,IAA5B,CAFmC;AAInCuD,IAAAA,IAAI,GAAI,GAAEG,IAAI,CAACC,GAAL,CAASJ,IAAI,GAAGA,IAAhB,CAAsB,EAAhC;AACD;AAED,SAAOK,2BAAa,CAACP,SAAD,CAAb,GAA2BE,IAAI,CAACrC,KAAL,CAAW,CAAX,EAAcmC,SAAd,CAA3B,GAAsDE,IAA7D;AACD;;MCrBYM,OAAO,GAAGrE,GAAG,IAAI;AAC5B,MAAI,CAACA,GAAD,IAAQ,CAACK,WAAK,CAACL,GAAD,CAAlB,EAAyB,OAAO,KAAP;AACzB,QAAMsE,KAAK,GAAG,6CAAd;AACA,SAAOC,OAAO,CAACD,KAAK,CAACX,IAAN,CAAW3D,GAAX,CAAD,CAAd;AACD;;MCJYwE,OAAO,GAAGxE,GAAG,IAAI;AAC5B,MAAI,CAACA,GAAD,IAAQ,CAACK,WAAK,CAACL,GAAD,CAAlB,EAAyB,OAAO,KAAP;AACzB,QAAMsE,KAAK,GAAG,6DAAd;AACA,SAAOC,OAAO,CAACD,KAAK,CAACX,IAAN,CAAW3D,GAAX,CAAD,CAAP,IAA4BA,GAAG,CAACE,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,EAAuB6B,MAAvB,GAAgC,EAAnE;AACD;;MCNY0C,KAAK,GAAGzE,GAAG,IAAI;AAC1B,QAAMsE,KAAK,GACT,8aADF;AAEA,SAAOC,OAAO,CAACD,KAAK,CAACX,IAAN,CAAW3D,GAAX,CAAD,CAAd;AACD;;MCFY0E,MAAM,GAAG1E,GAAG,IAAI;AAC3B,MAAI,CAACA,GAAD,IAAQ,CAACK,WAAK,CAACL,GAAD,CAAlB,EAAyB,OAAO,KAAP;AACzB,QAAMsE,KAAK,GACT,0EADF;AAEA,SAAOC,OAAO,CAACD,KAAK,CAACX,IAAN,CAAW3D,GAAX,CAAD,CAAd;AACD;;MCPY2E,SAAS,GAAG,CAAC3E,GAAD,EAAM4E,MAAM,GAAG,IAAf,KAAwB;AAC/C,MAAI;AACF,WAAOC,IAAI,CAACC,KAAL,CAAW9E,GAAX,CAAP;AACD,GAFD,CAGA,OAAO+E,CAAP,EAAU;AACRH,IAAAA,MAAM,IAAII,OAAO,CAACC,KAAR,CAAcF,CAAC,CAACG,OAAhB,CAAV;AACA,WAAO,IAAP;AACD;AACF;;MCRYC,MAAM,GAAGnF,GAAG,IAAI;AAC3B,MAAI,CAACA,GAAD,IAAQ,CAACA,GAAG,CAAC+B,MAAjB,EAAyB,OAAO/B,GAAP;AACzB,SAAOA,GAAG,CAACA,GAAG,CAAC+B,MAAJ,GAAa,CAAd,CAAH,KAAwB,GAAxB,GAA8B/B,GAAG,GAAG,GAApC,GAA0CA,GAAjD;AACD;;MCHYoF,QAAQ,GAAGpF,GAAG,IAAI;AAC7B,MAAI,CAACA,GAAD,IAAQ,CAACA,GAAG,CAAC+B,MAAjB,EAAyB,OAAO/B,GAAP;AACzB,SAAOA,GAAG,CAACA,GAAG,CAAC+B,MAAJ,GAAa,CAAd,CAAH,KAAwB,GAAxB,GAA8B/B,GAAG,CAAC0B,KAAJ,CAAU,CAAV,EAAa1B,GAAG,CAAC+B,MAAJ,GAAa,CAA1B,CAA9B,GAA6D/B,GAApE;AACD;;MCCYqF,SAAS,GAAGrF,GAAG,IAAI;AAC9B,MAAI,CAACK,WAAK,CAACL,GAAD,CAAV,EAAiB,OAAOA,GAAP;AAEjB,QAAMoC,KAAK,GAAGH,SAAS,CAACjC,GAAD,CAAvB;AACA,SAAQ,GAAEoC,KAAK,CAAC,CAAD,CAAL,CAAS1B,WAAT,EAAuB,GAAE0B,KAAK,CAACV,KAAN,CAAY,CAAZ,CAAe,EAAlD;AACD;;MCPY4D,SAAS,GAAGtF,GAAG,IACzBK,WAAK,CAACL,GAAD,CAAL,IACCA,GAAG,CACAmC,KADH,CACS,oBADT,EAEGQ,IAFH,CAEQ,GAFR,EAGGjC,WAHH,EADF,IAKAV;;MCJWuF,QAAQ,GAAGvF,GAAG,IAAI;AAC7B,MAAI,CAACK,WAAK,CAACL,GAAD,CAAV,EAAiB,OAAOA,GAAP;AACjB,MAAIwF,OAAO,GAAGxD,QAAQ,CAAChC,GAAD,CAAtB;AACA,SAAOwF,OAAO,CACXrD,KADI,CACE,GADF,EAEJM,GAFI,CAEAJ,IAAI,IAAKA,IAAI,IAAId,UAAU,CAACc,IAAD,CAAnB,IAA8B,EAFtC,EAGJM,IAHI,CAGC,GAHD,CAAP;AAID;;MCNY8C,SAAS,GAAG,CAACC,QAAD,EAAWC,KAAX,KAAqB;AAC5CA,EAAAA,KAAK,GAAGC,WAAK,CAACD,KAAD,CAAL,GAAeA,KAAf,GAAuB,CAACA,KAAD,CAA/B;AACA,SAAOA,KAAK,CAAC9F,MAAN,CACL,CAACgG,MAAD,EAASC,IAAT,KAAkB;AAChB,WAAOzF,WAAK,CAACyF,IAAD,CAAL,GACF,GAAED,MAAM,GAAGA,MAAM,GAAG,GAAZ,GAAkB,EAAG,GAAEC,IAAK,EAArC,CAAuCC,IAAvC,EADG,GAEHF,MAFJ;AAGD,GALI,EAMLxF,WAAK,CAACqF,QAAD,CAAL,GAAkBA,QAAlB,GAA6B,EANxB,CAAP;AAQD;;MCFYM,UAAU,GAAG,CAACC,OAAD,EAAUC,IAAV,EAAgBC,QAAQ,GAAG,EAA3B,EAA+BC,EAA/B,KAAsC;AAC9D,QAAMC,KAAK,GAAGC,QAAQ,CAAChC,KAAvB;AACAgC,EAAAA,QAAQ,CAAChC,KAAT,GAAiB8B,EAAE,IAAI,cAAvB;AACA,QAAMG,IAAI,GAAGD,QAAQ,CAACL,OAAD,EAAUC,IAAV,EAAgBC,QAAhB,CAArB;AACAG,EAAAA,QAAQ,CAAChC,KAAT,GAAiB+B,KAAjB;AAEA,SAAOE,IAAP;AACD;MAcYD,QAAQ,GAAG,CAACL,OAAD,EAAUC,IAAV,EAAgBC,QAAQ,GAAG,EAA3B,KAAkC;AACxDD,EAAAA,IAAI,GAAIM,aAAM,CAACN,IAAD,CAAN,IAAgBA,IAAjB,IAA0B,EAAjC;AACA,QAAM5B,KAAK,GAAGgC,QAAQ,CAAChC,KAAT,IAAkB,aAAhC;AAEA,SAAOjE,WAAK,CAAC4F,OAAD,CAAL,GACHA,OAAO,CAAC/F,OAAR,CAAgBoE,KAAhB,EAAuB,CAAChB,KAAD,EAAQmD,KAAR,KAAkB;AACzC,UAAM3G,IAAI,GAAG,CAAC2G,KAAK,IAAInD,KAAK,CAACoD,MAAN,CAAa,CAAb,EAAgBpD,KAAK,CAACvB,MAAN,GAAe,CAA/B,CAAV,EAA6CgE,IAA7C,EAAb;AACA,UAAMY,WAAW,GAAGC,OAAG,CAACV,IAAD,EAAOpG,IAAP,EAAaqG,QAAb,CAAvB;AACA,WAAO7F,aAAM,CAACqG,WAAD,CAAN,GACHA,WAAW,CAACT,IAAD,EAAOpG,IAAP,EAAaqG,QAAb,CADR,GAEHQ,WAFJ;AAGD,GANC,CADG,GAQH3B,OAAO,CAACC,KAAR,CAAe,kDAAf,KACEgB,OATN;AAUD;;MC/CYY,aAAa,GAAGC,QAAQ,IAAI;AACvC,MAAI,CAACA,QAAL,EAAe,OAAO,KAAP,CADwB;AAIvC,QAAMxC,KAAK,GAAG,4BAAd,CAJuC;AAOvC,QAAMyC,YAAY,GAAG,kCAArB,CAPuC;AAUvC,QAAMC,WAAW,GAAG,SAApB;AAEA,SAAO1C,KAAK,CAACX,IAAN,CAAWmD,QAAX,KACLC,YAAY,CAACpD,IAAb,CAAkBmD,QAAlB,CADK,IAELE,WAAW,CAACrD,IAAZ,CAAiBmD,QAAjB,CAFK,GAGH,KAHG,GAIH,IAJJ;AAKD;;ACtBD,MAAMG,YAAY,GAAG,CAAE,GAAF,EAAO,GAAP,CAArB;MAaaC,QAAQ,GAAG,CAAClH,GAAD,EAAMmH,MAAM,GAAGF,YAAf,KAAgC;AACtD,SACE5G,WAAK,CAACL,GAAD,CAAL,IACAmH,MAAM,CAACjG,IAAP,CAAYkG,KAAK,IAAIpH,GAAG,CAACqH,UAAJ,CAAeD,KAAf,KAAyBpH,GAAG,CAACsH,QAAJ,CAAaF,KAAb,CAA9C,CAFF;AAID;;MCVYG,UAAU,GAAGvH,GAAG,IAAI;AAC/B,MAAI,CAACK,WAAK,CAACL,GAAD,CAAV,EAAiB,OAAOwH,SAAP;AACjB,MAAIC,QAAQ,GAAG,EAAf;AACA,OAAK,IAAIjH,IAAT,IAAiBR,GAAjB,EAAsB;AACpByH,IAAAA,QAAQ,GAAGjH,IAAI,GAAGiH,QAAlB;AACD;AACD,SAAOA,QAAP;AACD;;MCRYC,wBAAwB,GAAG,CAACC,IAAD,EAAOrF,KAAP,EAAcvB,UAAU,GAAG,CAAC,GAAD,CAA3B,KAAqC;AAC3E,QAAM6G,OAAO,GAAG7G,UAAU,CAAC0B,GAAX,CAAezC,GAAG,IAAI2H,IAAI,CAAC7F,OAAL,CAAa9B,GAAb,EAAkBsC,KAAlB,CAAtB,EAAgDuF,IAAhD,EAAhB;AACA,SAAOD,OAAO,CAACE,IAAR,CAAapF,GAAG,IAAIA,GAAG,IAAI,CAA3B,CAAP;AACD;MAaYqF,iBAAiB,GAAG,CAACJ,IAAD,EAAOrF,KAAP,EAAcvB,UAAU,GAAG,CAAC,GAAD,CAA3B,KAAqC;AACpE,QAAMiH,cAAc,GAAGN,wBAAwB,CAACC,IAAD,EAAOrF,KAAP,EAAcvB,UAAd,CAA/C;AACA,SAAO4G,IAAI,CAAC9E,SAAL,CACLP,KADK,EAEL0F,cAAc,KAAK,CAAC,CAApB,GAAwBL,IAAI,CAAC5F,MAA7B,GAAsCiG,cAFjC,CAAP;AAID;;MCjBYC,eAAe,GAAG,CAACN,IAAD,EAAOrF,KAAP,EAAcvB,UAAU,GAAG,CAAC,GAAD,CAA3B,KAAqC;AAClE,QAAM0G,QAAQ,GAAGF,UAAU,CAACI,IAAD,CAA3B;AACA,QAAMO,aAAa,GAAGP,IAAI,CAAC5F,MAAL,GAAcO,KAApC;AACA,SAAOiF,UAAU,CAACQ,iBAAiB,CAACN,QAAD,EAAWS,aAAX,EAA0BnH,UAA1B,CAAlB,CAAjB;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}