{"version":3,"file":"stackTracePaths-d8971a4a.js","sources":["../../src/method/checkCall.js","../../src/method/complement.js","../../src/method/eitherFunc.js","../../src/method/debounce.js","../../src/method/doIt.js","../../src/method/memorize.js","../../src/method/runSeq.js","../../src/method/timedRun.js","../../src/method/throttle.js","../../src/method/throttleLast.js","../../src/method/limbo.js","../../src/method/uuid.js","../../src/method/noOp.js","../../src/method/parseErrorMessage.js","../../src/method/stackTracePaths.js"],"sourcesContent":["/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Check if the passed in method is a function, and calls it\n * @example\n * checkCall((param1) => { return param1 }, 'foo')\n * // Returns 'foo'\n * @function\n * @param {Function} method - function to call\n * @param {Object} params - params to pass to the method on call\n * @return {*} - whatever the passed in method returns\n */\nexport const checkCall = (method, ...params) => {\n  return isFunc(method) ? method(...params) : undefined\n}\n","/** @module Function */\n\nimport { validate } from '../validation'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Returns a new function that is the complement of predicate function `predicate`\n * @function\n * @param {Function} predicate\n * @returns {Function?} the complement of `predicate`, if it's a function, otherwise null\n * @example\n * const isNegative = x => (x < 0)\n * const isNonNegative = complement(isNegative)\n * isNonNegative(1) // true\n */\nexport const complement = predicate => {\n  const [valid] = validate({ predicate }, { predicate: isFunc })\n  return valid ? (...args) => !predicate(...args) : null\n}\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Returns the first param if it's a function.\n * <br/>If first param is not a function, returns second param.\n * @example\n * eitherFunc(() => {}, 'bar')\n * // Returns first param because it's a function.\n * @example\n * eitherFunc('foo', 'bar')\n * // Returns 'bar'\n * @function\n * @param {Function} func1 - return if is func\n * @param {Function} func2 - use if first is not an object\n * @returns {Function}\n */\nexport const eitherFunc = (func1, func2) => (isFunc(func1) && func1) || func2\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Limits the amount of calls to a function over time\n * @example\n * debounce(myFunction)\n * // Calls myFunction after the default 250 ms\n * @example\n * debounce(myFunction, 500)\n * // Calls myFunction after 500 ms\n * @example\n * debounce(myFunction, 500, true)\n * // Calls myFunction immediately\n * @function\n * @param {Function} func - function to call\n * @param {Number} wait - how long to wait between function calls\n * @param {Boolean} immediate - should call immediately\n * @return { void }\n */\nexport const debounce = (func, wait = 250, immediate = false) => {\n  let timeout\n  function wrapFunc(...args) {\n    if (!isFunc(func)) return null\n\n    const context = this\n    const later = () => {\n      timeout = null\n      !immediate && func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow) return isFunc(func) && func.apply(context, args)\n  }\n  return wrapFunc\n}\n","/** @module Function */\n\nimport { isNum } from '../number/isNum'\nimport { isFunc } from './isFunc'\n\n/**\n * Execute a method n times.\n * <br/>Callback params - does not include number || callback method\n * @function\n * @example\n * doIt(10, window, [], (index, arr) => { arr.push(index) }) === [ 0,1,2 ... 8,9 ]\n * @param {Number} args.0 - number of times to call the callback\n * @param {parent} args.1 - value to bind the method call to ( this )\n * @param {Function} last arg of args array - method to call\n * @return { void }\n */\nexport const doIt = (...args) => {\n  const params = args.slice()\n  const num = params.shift()\n  const bindTo = params.shift()\n  const cb = params.pop()\n  if (!isNum(num) || !isFunc(cb)) return []\n\n  const doItAmount = new Array(num)\n  const responses = []\n  for (let i = 0; i < doItAmount.length; i++) {\n    const data = cb.call(bindTo, i, ...params)\n    if (data === false) break\n    responses.push(data)\n  }\n\n  return responses\n}\n","/** @module Function */\n\nimport { isNum } from '../number/isNum'\nimport { hasOwn } from '../object/hasOwn'\nimport { isFunc } from './isFunc'\n\n/**\n * Creates a method to memorize passed in methods output\n * @example\n * memorize(myFunction, cacheKeyFunction)\n * @example\n * memorize(myFunction, cacheKeyFunction, 100)\n * @function\n * @param {Function} func - method to memorize output of\n * @param {Function} getCacheKey - gets the key to save cached output\n *\n * @return {Function} memorized function with cache\n */\nexport const memorize = (func, getCacheKey, limit = 1) => {\n  if (!isFunc(func) || (getCacheKey && !isFunc(getCacheKey)))\n    return console.error('Error: Expected a function', func, getCacheKey)\n\n  let memorized = function () {\n    const cache = memorized.cache\n    const key = getCacheKey ? getCacheKey.apply(this, arguments) : arguments[0]\n\n    if (hasOwn(cache, key)) return cache[key]\n\n    const result = func.apply(this, arguments)\n\n    isNum(limit) && Object.keys(cache).length < limit\n      ? (cache[key] = result)\n      : (memorized.cache = { [key]: result })\n\n    return result\n  }\n\n  memorized.cache = {}\n  memorized.destroy = () => {\n    getCacheKey = undefined\n    memorized.cache = undefined\n    memorized.destroy = undefined\n    memorized = undefined\n  }\n\n  return memorized\n}\n","import { validate } from '../validation/validate'\nimport { isArr } from '../array/isArr'\nimport { isFunc } from './isFunc'\n/** @module Function */\n\nimport { deepClone } from '../collection/deepClone'\n\n/**\n * Calls each promise-returning function in array `asyncFns`,\n * but awaits each before calling the next. Will pass the\n * index and resolved values of complete functions to each subsequent\n * function, in case any need them.\n * @function\n * @param {Array<Function>} asyncFns - array of functions to call in sequence.\n * Each will be passed (currentIndex, resultsSoFar)\n * @param {boolean?} [options.cloneResults=false] - if true, each function will be\n * passed a deep clone of the results array, rather than the reference to it.\n * @param {boolean?} [options.returnOriginal=true] - if true, any member of asyncFns that\n * is not a function will have its corresponding value in the return array be itself.\n * If this is false, that value will be undefined.\n * @return {Promise<Array<*>>} - returns a promise that resolves to an array of all the\n * asyncFns' return values\n * @example\n * const results = await runSeq(asyncFunctions)\n * @example\n * const results = await runSeq(asyncFunctions, { cloneResults: true, returnOriginal: false })\n */\nexport const runSeq = async (asyncFns = [], options = {}) => {\n  const [valid] = validate({ asyncFns }, { asyncFns: isArr })\n  if (!valid) return []\n\n  const { cloneResults = false, returnOriginal = true } = options\n\n  const results = []\n\n  for (const fn of asyncFns) {\n    const result = isFunc(fn)\n      ? await fn(results.length, cloneResults ? deepClone(results) : results)\n      : returnOriginal\n        ? fn\n        : undefined\n    results.push(result)\n  }\n\n  return results\n}\n","/** @module Function */\n\nimport { validate } from '../validation/validate'\nimport { isFunc } from './isFunc'\n\n/**\n * Executes and times the function `fn`.\n * @function\n * @param {Function} fn\n * @param {...*?} args - any number of arguments to pass to fn when it is called\n * @return {Promise<Array<*, number>>} [ fn output, execution time in ms ]\n * @example\n * const [ result, executionTime ] = timedRun(() => http.get(url)))\n * @example\n * const [ result, executionTime ] = timedRun(http.get, url)\n */\nexport const timedRun = async (fn, ...args) => {\n  const [valid] = validate({ fn }, { fn: isFunc })\n  if (!valid) return [ undefined, -1 ]\n\n  const startTime = new Date()\n  const result = await fn(...args)\n  return [ result, new Date() - startTime ]\n}\n","/** @module Function */\n\n/**\n * Throttle function calls to only execute once over a wait period\n * @example\n * throttle(() => console.log('throttled'), 50)()\n * @function\n * @param {*} func - method to call after wait\n * @param {Number} [wait=100] time to wait between calls\n * @return {Function} throttled function\n */\nexport const throttle = (func, wait = 100) => {\n  let waiting = false\n  return function (...args) {\n    if (waiting) return\n    waiting = true\n    func.apply(this, args)\n    return setTimeout(() => {\n      waiting = false\n    }, wait)\n  }\n}\n","/** @module Function */\n\n/**\n * Ensures the last call to the throttled function get called.\n * <br/>Will wait the allotted time, before calling the last call to it.\n * <br/>The final call will not execute until no more calls are made,\n * <br/>Accepts a callback to call each time the throttle called,\n * @example\n * throttleLast(() => {}, () => {})()\n * // throttle function\n * @function\n * @param {Function} func - method to call after wait\n * @param {Function} cb - method to call after throttle function is called\n * @param {Number} [wait=100] time to wait until executing func param\n * @return {Function} throttled function\n */\nexport const throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout\n  return function (...args) {\n    // If the throttle already exists clear it, and create it again\n    if (throttleTimeout) clearTimeout(throttleTimeout)\n    // Store a reference to the timeout\n    // Will wait the allotted time until calling the final call to it\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args)\n      clearTimeout(throttleTimeout)\n    }, wait)\n    typeof cb === 'function' && cb()\n  }\n}\n","/** @module Function */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Response returned from a limbo promise\n * @typedef TLimboResponse\n * @private\n * @type {Array}\n */\n\n/**\n * Adds catch to a promise for better error handling of await functions\n * <br/>Removes the need for wrapping await in a try / catch\n * <br/>First argument is an Error when the promise throws or null when it resolves\n * <br/>Second argument is the response from the resolved promise\n * @example\n * const [ err, data ] = await limbo(promiseFunction())\n * // returns an array\n * // * err will be undefined if no error was thrown\n * // * data will be the response from the promiseFunction\n * @function\n * @param {Promise<Function>} promise - Promise to be resolved\n * @return {Promise<TLimboResponse>} - Slot 1 => error, Slot 2 => response from promise\n */\nexport const limbo = promise => {\n  return !promise || !isFunc(promise.then)\n    ? [\n        new Error(`A promise or thenable is required as the first argument!`),\n        null,\n      ]\n    : promise.then(data => [ null, data ]).catch(err => [ err, undefined ])\n}\n\n/**\n * Converts a method with a callback as the last argument into a promise\n * @function\n * @param {*} cb - method to wrap in a promise\n * @param {*} args - Arguments to pass to the callback method\n * @example\n * limboify(fs.rename, 'my/file.txt', 'my/renamed-file.txt')\n * @example\n * limboify(fs.mkdir, 'my/new/directory', { recursive: true })\n *\n * @returns {Promise|*} - Success response of fs.rename method\n */\nexport const limboify = (cb, ...args) => {\n  return limbo(\n    new Promise((res, rej) =>\n      cb(...args, (err, success) => (err ? rej(err) : res(success || true)))\n    )\n  )\n}\n","/** @module Function */\n\n/**\n * Creates a uuid, unique up to around 20 million iterations.\n * @example\n * uuid()\n * // New uuid as a string\n * @function\n * @param {Number} [start] of the uuid\n * @return {String} - build uuid\n */\nexport const uuid = a =>\n  a\n    ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)\n    : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid)\n","/** @module Function */\n\n/**\n * Reusable empty function that is a no-op\n * @function\n * @returns {void}\n */\nexport const noOp = () => {}\n","/** @module Function */\n\nimport { isStr } from '../string/isStr'\nimport { isObj } from '../object/isObj'\nimport { isEmpty } from '../ext/isEmpty'\n\n/**\n * Extracts the message from the exception, whether string or object\n * @function\n * @param {*} exception - Error to be extracted\n * @return {string?} - The message or null if no message is present\n * @example\n * try {\n *   throwSomeException()\n * }\n * catch (err) {\n *   const message = parseErrorMessage(err) || 'Error'\n * }\n */\nexport const parseErrorMessage = exception => {\n  return isStr(exception) && !isEmpty(exception)\n    ? exception\n    : isObj(exception)\n      ? exception.message\n      : null\n}\n","import { isFunc } from './isFunc'\n\nconst defFilters = [ `node:internal`, `node_modules/jest` ]\n\n/**\n * Gets the paths from a stacktrace as CallSites and returns them\n * @param {Array|Function} filter - List of paths to ignore, or function that returns truthy to ignore\n *\n * @returns {Array<string>} - List of paths from the stackTrace\n */\nexport const stackTracePaths = (filter = defFilters) => {\n  const orgPreStackTrace = Error.prepareStackTrace\n  Error.prepareStackTrace = (_, stack) => stack\n\n  const stack = new Error().stack.slice(1)\n  Error.prepareStackTrace = orgPreStackTrace\n\n  return stack.reduce((acc, cs) => {\n    const loc = cs.getFileName()\n    if (!loc) return acc\n\n    const ignore = isFunc(filter)\n      ? filter(loc, cs, stack)\n      : Boolean(\n        filter.length && filter.find(filterLoc => loc.includes(filterLoc))\n      )\n\n    !ignore && acc.push(loc)\n\n    return acc\n  }, [])\n}\n"],"names":["checkCall","method","params","isFunc","undefined","complement","predicate","valid","validate","args","eitherFunc","func1","func2","debounce","func","wait","immediate","timeout","wrapFunc","context","later","apply","callNow","clearTimeout","setTimeout","doIt","slice","num","shift","bindTo","cb","pop","isNum","doItAmount","Array","responses","i","length","data","call","push","memorize","getCacheKey","limit","console","error","memorized","cache","key","arguments","hasOwn","result","Object","keys","destroy","runSeq","asyncFns","options","isArr","cloneResults","returnOriginal","results","fn","deepClone","timedRun","startTime","Date","throttle","waiting","throttleLast","throttleTimeout","limbo","promise","then","Error","catch","err","limboify","Promise","res","rej","success","uuid","a","Math","random","toString","replace","noOp","parseErrorMessage","exception","isStr","isEmpty","isObj","message","defFilters","stackTracePaths","filter","orgPreStackTrace","prepareStackTrace","_","stack","reduce","acc","cs","loc","getFileName","ignore","Boolean","find","filterLoc","includes"],"mappings":"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"}