{"version":3,"file":"useAutocompleteItems.js","sources":["../../../src/hooks/useAutocompleteItems.js"],"sourcesContent":["import { isEmpty, pipeline, isStr, isObj, noPropArr } from '@keg-hub/jsutils'\nimport { useState, useMemo } from 'react'\n\n/**\n * @param {string} str\n * @returns {string} str in lower case\n */\nconst ignoreCase = str => str.toLowerCase()\n\n/**\n * @param {string} str\n * @returns {string} str normalized without accents, so Ã is converted to A\n */\nconst ignoreAccents = str =>\n  str.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n\n/**\n * Formats the menu item to be an object, or null if invalid type\n * @param {Object | String} item\n * @param {Number} index\n * @return {Object?} returns null if invalid, otherwise an object in form { key, text }\n */\nconst formatItem = (item, index) => {\n  const value = item.text || item.value\n  if (isObj(item) && isStr(value))\n    return { text: value, key: item.key || value, index }\n  else if (isStr(item)) return { text: item, key: item, index }\n  else return null\n}\n\n/**\n * @param {string} str\n * @return {string} string trimmed\n */\nconst trimStr = str => str?.trim()\n\n/**\n *\n * @param {string} text - user input text\n * @param {Object} item - one of the possible autocomplete values, of form { text, key }\n * @return {boolean} true if the text matches the item's text, ignoring casing and accents\n */\nconst textMatches = (text, item) => {\n  const itemComparisonStr = pipeline(item.text, ignoreCase, ignoreAccents)\n  const textComparisonStr = pipeline(text, trimStr, ignoreCase, ignoreAccents)\n  return itemComparisonStr.includes(textComparisonStr)\n}\n\n/**\n * Returns a new array containing a subset of possibleValues, each of which is:\n *  - unique; and\n *  - either a substring of `text` or the same string.\n * The filtering ignores casing and accents.\n * @param {String} text - text to check (e.g. user input so far)\n * @param {Array<string | Object>} possibleValues - string or object { text, key? } array\n * @returns {Array<Object>} the new array of items, without duplicates\n */\nexport const getItemsMatchingText = (\n  text,\n  possibleValues,\n  emptyShowList,\n  selectedItem\n) => {\n  if (!isStr(text)) return []\n\n  // in one pass: format values, keep the matching ones, and ignore duplicates (by key) and invalid items\n  const result = possibleValues.reduce(\n    (state, nextItem) => {\n      // ensure item is of form { key, text }\n      const formattedItem = formatItem(nextItem, state.counter)\n\n      // invalid item, so just ignore\n      if (!formattedItem) return state\n\n      const addItem =\n        selectedItem?.activeShowList ||\n        (!text && emptyShowList) ||\n        textMatches(text, formattedItem)\n\n      // add the item if it matches the text and we haven't seen its key before\n      if (addItem && !state.keys.has(formattedItem.key)) {\n        state.keys.add(formattedItem.key)\n        state.arr.push(formattedItem)\n\n        state.counter++ // used for item indices\n      }\n\n      return state\n    },\n    {\n      arr: [],\n      keys: new Set(),\n      counter: 0,\n    }\n  )\n\n  return result.arr\n}\n\n/**\n * Custom hook for acquiring menu items that are filtered based on matches to `text`.\n * @param {String} text - user input\n * @param {Array<string> | Array<object>} menuItems - all menu items\n * @return {Array} - [\n *  autocompleteItems: subset of menuItems that have an overlap with text. These will be formatted to object form.\n *  setSelectedItem: callback to set the currently selected item in the autocomplete component\n *  selectedItem: the currently selected item\n * ]\n */\nexport const useAutocompleteItems = (\n  text,\n  menuItems = noPropArr,\n  emptyShowList\n) => {\n  const curItem = useMemo(() => {\n    return menuItems\n      .filter(node => text === node.text || text === node.value)\n      .find(val => val)\n  }, [ text, menuItems ])\n\n  const [ selectedItem, setSelectedItem ] = useState(curItem || null)\n  const items = useMemo(\n    () =>\n      !selectedItem?.activeShowList &&\n      !emptyShowList &&\n      (isEmpty(text) || selectedItem?.text === text)\n        ? []\n        : getItemsMatchingText(text, menuItems, emptyShowList, selectedItem),\n    [ text, menuItems, selectedItem ]\n  )\n\n  return [ items, setSelectedItem, selectedItem ]\n}\n"],"names":["ignoreCase","str","toLowerCase","ignoreAccents","normalize","replace","formatItem","item","index","value","text","isObj","isStr","key","trimStr","trim","textMatches","itemComparisonStr","pipeline","textComparisonStr","includes","getItemsMatchingText","possibleValues","emptyShowList","selectedItem","result","reduce","state","nextItem","formattedItem","counter","addItem","activeShowList","keys","has","add","arr","push","Set","useAutocompleteItems","menuItems","noPropArr","curItem","useMemo","filter","node","find","val","useState","setSelectedItem","items","isEmpty"],"mappings":"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"}